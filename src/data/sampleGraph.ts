import { KnowledgeGraph } from '@/types/graph';

export const sampleGraph: KnowledgeGraph = {
  globalNodes: [
    {
      id: 'identify-data-structure',
      name: 'Identifying appropriate data structure for lookup',
      level: 0,
      cme: {
        highestConceptLevel: 4,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 95, 3: 85, 4: 70 },
      },
      le: {
        passiveTime: 10,
        activeTime: 25,
        weightedEngagementTime: 30,
        persistenceSignals: { reattemptAfterWrong: true, returnAfterExit: false },
        persistenceFactor: 0.25,
        finalLE: 37.5,
      },
      description: 'Selecting the right data structure based on access patterns and performance requirements.',
    },
    {
      id: 'key-existence-check',
      name: 'Checking whether a key exists',
      level: 1,
      cme: {
        highestConceptLevel: 3,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 90, 3: 75 },
      },
      le: {
        passiveTime: 5,
        activeTime: 15,
        weightedEngagementTime: 17.5,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 17.5,
      },
      description: 'Verifying the presence of a key in a key-value mapping before accessing its value.',
    },
    {
      id: 'value-accumulation',
      name: 'Accumulating multiple values per key',
      level: 2,
      cme: {
        highestConceptLevel: 5,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application', 'Complex application'],
        independence: 'Lightly Scaffolded',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 92, 3: 80, 4: 65, 5: 45 },
      },
      le: {
        passiveTime: 15,
        activeTime: 35,
        weightedEngagementTime: 42.5,
        persistenceSignals: { reattemptAfterWrong: true, returnAfterExit: true },
        persistenceFactor: 0.5,
        finalLE: 63.75,
      },
      description: 'Building collections of values associated with the same key, such as grouping items.',
    },
    {
      id: 'iterate-key-value',
      name: 'Iterating over key-value pairs',
      level: 1,
      cme: {
        highestConceptLevel: 4,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 88, 3: 72, 4: 55 },
      },
      le: {
        passiveTime: 8,
        activeTime: 20,
        weightedEngagementTime: 24,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 24,
      },
      description: 'Processing each key-value pair in a mapping sequentially.',
    },
    {
      id: 'frequency-counting',
      name: 'Counting occurrences of elements',
      level: 2,
      cme: {
        highestConceptLevel: 4,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application'],
        independence: 'Independent',
        retention: 'Aging',
        evidenceByLevel: { 1: 100, 2: 85, 3: 68, 4: 50 },
      },
      le: {
        passiveTime: 10,
        activeTime: 25,
        weightedEngagementTime: 30,
        persistenceSignals: { reattemptAfterWrong: true, returnAfterExit: false },
        persistenceFactor: 0.25,
        finalLE: 37.5,
      },
      description: 'Tracking how many times each unique element appears in a collection.',
    },
    {
      id: 'default-value-handling',
      name: 'Providing default values for missing keys',
      level: 1,
      cme: {
        highestConceptLevel: 3,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 88, 3: 70 },
      },
      le: {
        passiveTime: 6,
        activeTime: 12,
        weightedEngagementTime: 15,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 15,
      },
      description: 'Returning a fallback value when a requested key does not exist.',
    },
    {
      id: 'set-membership',
      name: 'Checking membership in a unique collection',
      level: 1,
      cme: {
        highestConceptLevel: 3,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 92, 3: 78 },
      },
      le: {
        passiveTime: 5,
        activeTime: 12,
        weightedEngagementTime: 14.5,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 14.5,
      },
      description: 'Efficiently testing if an element exists in a collection of unique items.',
    },
    {
      id: 'set-operations',
      name: 'Performing set operations (union, intersection, difference)',
      level: 2,
      cme: {
        highestConceptLevel: 5,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application', 'Complex application'],
        independence: 'Lightly Scaffolded',
        retention: 'Aging',
        evidenceByLevel: { 1: 100, 2: 85, 3: 70, 4: 52, 5: 35 },
      },
      le: {
        passiveTime: 12,
        activeTime: 30,
        weightedEngagementTime: 36,
        persistenceSignals: { reattemptAfterWrong: true, returnAfterExit: false },
        persistenceFactor: 0.25,
        finalLE: 45,
      },
      description: 'Combining or comparing sets using mathematical set operations.',
    },
    {
      id: 'duplicate-detection',
      name: 'Detecting and removing duplicates',
      level: 2,
      cme: {
        highestConceptLevel: 4,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 90, 3: 75, 4: 60 },
      },
      le: {
        passiveTime: 8,
        activeTime: 18,
        weightedEngagementTime: 22,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 22,
      },
      description: 'Identifying repeated elements and producing a unique collection.',
    },
    {
      id: 'conditional-branching',
      name: 'Making decisions based on conditions',
      level: 0,
      cme: {
        highestConceptLevel: 6,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application', 'Complex application', 'Transfer'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 98, 3: 92, 4: 85, 5: 72, 6: 55 },
      },
      le: {
        passiveTime: 8,
        activeTime: 20,
        weightedEngagementTime: 24,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 24,
      },
      description: 'Executing different code paths based on boolean conditions.',
    },
    {
      id: 'sequential-iteration',
      name: 'Processing elements one by one in order',
      level: 0,
      cme: {
        highestConceptLevel: 5,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application', 'Complex application'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 95, 3: 88, 4: 78, 5: 62 },
      },
      le: {
        passiveTime: 6,
        activeTime: 18,
        weightedEngagementTime: 21,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 21,
      },
      description: 'Traversing a sequence and performing operations on each element.',
    },
    {
      id: 'grouping-by-key',
      name: 'Grouping items by a computed key',
      level: 3,
      cme: {
        highestConceptLevel: 5,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application', 'Complex application'],
        independence: 'Lightly Scaffolded',
        retention: 'Aging',
        evidenceByLevel: { 1: 100, 2: 82, 3: 68, 4: 50, 5: 32 },
      },
      le: {
        passiveTime: 15,
        activeTime: 40,
        weightedEngagementTime: 47.5,
        persistenceSignals: { reattemptAfterWrong: true, returnAfterExit: true },
        persistenceFactor: 0.5,
        finalLE: 71.25,
      },
      description: 'Organizing a collection into groups based on a derived attribute.',
    },
    {
      id: 'finding-extremes',
      name: 'Finding maximum or minimum values',
      level: 2,
      cme: {
        highestConceptLevel: 4,
        levelLabels: ['Recognition', 'Recall (simple)', 'Recall (complex)', 'Direct application'],
        independence: 'Independent',
        retention: 'Current',
        evidenceByLevel: { 1: 100, 2: 90, 3: 78, 4: 62 },
      },
      le: {
        passiveTime: 6,
        activeTime: 15,
        weightedEngagementTime: 18,
        persistenceSignals: { reattemptAfterWrong: false, returnAfterExit: false },
        persistenceFactor: 0,
        finalLE: 18,
      },
      description: 'Identifying the largest or smallest element in a collection.',
    },
  ],
  edges: [
    { from: 'identify-data-structure', to: 'key-existence-check', reason: 'Must understand data structure choices to know when key checks apply' },
    { from: 'identify-data-structure', to: 'set-membership', reason: 'Understanding data structures enables choosing between sets and other collections' },
    { from: 'key-existence-check', to: 'value-accumulation', reason: 'Must check key existence before accumulating values' },
    { from: 'key-existence-check', to: 'default-value-handling', reason: 'Default values are used when key existence check fails' },
    { from: 'key-existence-check', to: 'frequency-counting', reason: 'Counting requires checking if key exists to increment' },
    { from: 'conditional-branching', to: 'key-existence-check', reason: 'Key existence is a conditional check' },
    { from: 'sequential-iteration', to: 'iterate-key-value', reason: 'Iterating key-value pairs is a specific form of iteration' },
    { from: 'sequential-iteration', to: 'frequency-counting', reason: 'Counting requires iterating through elements' },
    { from: 'set-membership', to: 'set-operations', reason: 'Set operations build on membership concepts' },
    { from: 'set-membership', to: 'duplicate-detection', reason: 'Duplicate detection uses set membership' },
    { from: 'value-accumulation', to: 'grouping-by-key', reason: 'Grouping is accumulating items into lists by key' },
    { from: 'iterate-key-value', to: 'grouping-by-key', reason: 'Grouping requires iterating to assign items' },
    { from: 'sequential-iteration', to: 'finding-extremes', reason: 'Finding extremes requires examining all elements' },
    { from: 'conditional-branching', to: 'finding-extremes', reason: 'Comparing elements requires conditional logic' },
  ],
  courses: {
    'Python Data Structures': {
      nodes: [
        { id: 'identify-data-structure', inCourse: true },
        { id: 'key-existence-check', inCourse: true },
        { id: 'value-accumulation', inCourse: true },
        { id: 'iterate-key-value', inCourse: true },
        { id: 'frequency-counting', inCourse: true },
        { id: 'default-value-handling', inCourse: true },
        { id: 'set-membership', inCourse: true },
        { id: 'set-operations', inCourse: true },
        { id: 'duplicate-detection', inCourse: true },
        { id: 'conditional-branching', inCourse: false },
        { id: 'sequential-iteration', inCourse: false },
        { id: 'grouping-by-key', inCourse: true },
        { id: 'finding-extremes', inCourse: false },
      ],
    },
  },
  questionPaths: {
    'Given a list of words, count the frequency of each word': [
      'sequential-iteration',
      'key-existence-check',
      'default-value-handling',
      'frequency-counting',
    ],
    'Group a list of students by their grade level': [
      'sequential-iteration',
      'key-existence-check',
      'value-accumulation',
      'grouping-by-key',
    ],
    'Find all unique elements that appear in both lists': [
      'set-membership',
      'set-operations',
      'duplicate-detection',
    ],
  },
};
